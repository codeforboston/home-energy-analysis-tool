{
  "version": 3,
  "sources": ["../../../../app/routes/settings+/profile.photo.tsx"],
  "sourcesContent": ["// REMIX HMR BEGIN\nif (!window.$RefreshReg$ || !window.$RefreshSig$ || !window.$RefreshRuntime$) {\n  console.warn('remix:hmr: React Fast Refresh only works when the Remix compiler is running in development mode.');\n} else {\n  var prevRefreshReg = window.$RefreshReg$;\n  var prevRefreshSig = window.$RefreshSig$;\n  window.$RefreshReg$ = (type, id) => {\n    window.$RefreshRuntime$.register(type, \"\\\"app/routes/settings+/profile.photo.tsx\\\"\" + id);\n  }\n  window.$RefreshSig$ = window.$RefreshRuntime$.createSignatureFunctionForTransform;\n}\nvar _s = $RefreshSig$();\nimport * as __hmr__ from \"remix:hmr\";\nif (import.meta) {\n  import.meta.hot = __hmr__.createHotContext(\n  //@ts-expect-error\n  \"app/routes/settings+/profile.photo.tsx\");\n  import.meta.hot.lastModified = \"1706218436656.8838\";\n}\n// REMIX HMR END\n\nimport { conform, useForm } from '@conform-to/react';\nimport { getFieldsetConstraint, parse } from '@conform-to/zod';\nimport { json, redirect, unstable_createMemoryUploadHandler, unstable_parseMultipartFormData } from '@remix-run/node';\nimport { Form, useActionData, useLoaderData, useNavigation } from '@remix-run/react';\nimport { useState } from 'react';\nimport { AuthenticityTokenInput } from 'remix-utils/csrf/react';\nimport { z } from 'zod';\nimport { ErrorList } from '#app/components/forms.tsx';\nimport { Button } from '#app/components/ui/button.tsx';\nimport { Icon } from '#app/components/ui/icon.tsx';\nimport { StatusButton } from '#app/components/ui/status-button.tsx';\nimport { requireUserId } from '#app/utils/auth.server.ts';\nimport { validateCSRF } from '#app/utils/csrf.server.ts';\nimport { prisma } from '#app/utils/db.server.ts';\nimport { getUserImgSrc, invariantResponse, useDoubleCheck, useIsPending } from '#app/utils/misc.tsx';\nexport const handle = {\n  breadcrumb: <Icon name=\"avatar\">Photo</Icon>,\n  getSitemapEntries: () => null\n};\nconst MAX_SIZE = 1024 * 1024 * 3; // 3MB\n\nconst DeleteImageSchema = z.object({\n  intent: z.literal('delete')\n});\nconst NewImageSchema = z.object({\n  intent: z.literal('submit'),\n  photoFile: z.instanceof(File).refine(file => file.size > 0, 'Image is required').refine(file => file.size <= MAX_SIZE, 'Image size must be less than 3MB')\n});\nconst PhotoFormSchema = z.union([DeleteImageSchema, NewImageSchema]);\nexport async function loader({\n  request\n}) {\n  const userId = await requireUserId(request);\n  const user = await prisma.user.findUnique({\n    where: {\n      id: userId\n    },\n    select: {\n      id: true,\n      name: true,\n      username: true,\n      image: {\n        select: {\n          id: true\n        }\n      }\n    }\n  });\n  invariantResponse(user, 'User not found', {\n    status: 404\n  });\n  return json({\n    user\n  });\n}\nexport async function action({\n  request\n}) {\n  const userId = await requireUserId(request);\n  const formData = await unstable_parseMultipartFormData(request, unstable_createMemoryUploadHandler({\n    maxPartSize: MAX_SIZE\n  }));\n  await validateCSRF(formData, request.headers);\n  const submission = await parse(formData, {\n    schema: PhotoFormSchema.transform(async data => {\n      if (data.intent === 'delete') return {\n        intent: 'delete'\n      };\n      if (data.photoFile.size <= 0) return z.NEVER;\n      return {\n        intent: data.intent,\n        image: {\n          contentType: data.photoFile.type,\n          blob: Buffer.from(await data.photoFile.arrayBuffer())\n        }\n      };\n    }),\n    async: true\n  });\n  if (submission.intent !== 'submit') {\n    return json({\n      status: 'idle',\n      submission\n    });\n  }\n  if (!submission.value) {\n    return json({\n      status: 'error',\n      submission\n    }, {\n      status: 400\n    });\n  }\n  const {\n    image,\n    intent\n  } = submission.value;\n  if (intent === 'delete') {\n    await prisma.userImage.deleteMany({\n      where: {\n        userId\n      }\n    });\n    return redirect('/settings/profile');\n  }\n  await prisma.$transaction(async $prisma => {\n    await $prisma.userImage.deleteMany({\n      where: {\n        userId\n      }\n    });\n    await $prisma.user.update({\n      where: {\n        id: userId\n      },\n      data: {\n        image: {\n          create: image\n        }\n      }\n    });\n  });\n  return redirect('/settings/profile');\n}\nexport default function PhotoRoute() {\n  _s();\n  const data = useLoaderData();\n  const doubleCheckDeleteImage = useDoubleCheck();\n  const actionData = useActionData();\n  const navigation = useNavigation();\n  const [form, fields] = useForm({\n    id: 'profile-photo',\n    constraint: getFieldsetConstraint(PhotoFormSchema),\n    lastSubmission: actionData?.submission,\n    onValidate({\n      formData\n    }) {\n      // otherwise, the best error zod gives us is \"Invalid input\" which is not\n      // enough\n      if (formData.get('intent') === 'delete') {\n        return parse(formData, {\n          schema: DeleteImageSchema\n        });\n      }\n      return parse(formData, {\n        schema: NewImageSchema\n      });\n    },\n    shouldRevalidate: 'onBlur'\n  });\n  const isPending = useIsPending();\n  const pendingIntent = isPending ? navigation.formData?.get('intent') : null;\n  const lastSubmissionIntent = actionData?.submission.value?.intent;\n  const [newImageSrc, setNewImageSrc] = useState(null);\n  return <div>\n\t\t\t<Form method=\"POST\" encType=\"multipart/form-data\" className=\"flex flex-col items-center justify-center gap-10\" onReset={() => setNewImageSrc(null)} {...form.props}>\n\t\t\t\t<AuthenticityTokenInput />\n\t\t\t\t<img src={newImageSrc ?? (data.user ? getUserImgSrc(data.user.image?.id) : '')} className=\"h-52 w-52 rounded-full object-cover\" alt={data.user?.name ?? data.user?.username} />\n\t\t\t\t<ErrorList errors={fields.photoFile.errors} id={fields.photoFile.id} />\n\t\t\t\t<div className=\"flex gap-4\">\n\t\t\t\t\t{/*\n      We're doing some kinda odd things to make it so this works well\n      without JavaScript. Basically, we're using CSS to ensure the right\n      buttons show up based on the input's \"valid\" state (whether or not\n      an image has been selected). Progressive enhancement FTW!\n      */}\n\t\t\t\t\t<input {...conform.input(fields.photoFile, {\n          type: 'file'\n        })} accept=\"image/*\" className=\"peer sr-only\" required tabIndex={newImageSrc ? -1 : 0} onChange={e => {\n          const file = e.currentTarget.files?.[0];\n          if (file) {\n            const reader = new FileReader();\n            reader.onload = event => {\n              setNewImageSrc(event.target?.result?.toString() ?? null);\n            };\n            reader.readAsDataURL(file);\n          }\n        }} />\n\t\t\t\t\t<Button asChild className=\"cursor-pointer peer-valid:hidden peer-focus-within:ring-4 peer-focus-visible:ring-4\">\n\t\t\t\t\t\t<label htmlFor={fields.photoFile.id}>\n\t\t\t\t\t\t\t<Icon name=\"pencil-1\">Change</Icon>\n\t\t\t\t\t\t</label>\n\t\t\t\t\t</Button>\n\t\t\t\t\t<StatusButton name=\"intent\" value=\"submit\" type=\"submit\" className=\"peer-invalid:hidden\" status={pendingIntent === 'submit' ? 'pending' : lastSubmissionIntent === 'submit' ? actionData?.status ?? 'idle' : 'idle'}>\n\t\t\t\t\t\tSave Photo\n\t\t\t\t\t</StatusButton>\n\t\t\t\t\t<Button type=\"reset\" variant=\"destructive\" className=\"peer-invalid:hidden\">\n\t\t\t\t\t\t<Icon name=\"trash\">Reset</Icon>\n\t\t\t\t\t</Button>\n\t\t\t\t\t{data.user.image?.id ? <StatusButton className=\"peer-valid:hidden\" variant=\"destructive\" {...doubleCheckDeleteImage.getButtonProps({\n          type: 'submit',\n          name: 'intent',\n          value: 'delete'\n        })} status={pendingIntent === 'delete' ? 'pending' : lastSubmissionIntent === 'delete' ? actionData?.status ?? 'idle' : 'idle'}>\n\t\t\t\t\t\t\t<Icon name=\"trash\">\n\t\t\t\t\t\t\t\t{doubleCheckDeleteImage.doubleCheck ? 'Are you sure?' : 'Delete'}\n\t\t\t\t\t\t\t</Icon>\n\t\t\t\t\t\t</StatusButton> : null}\n\t\t\t\t</div>\n\t\t\t\t<ErrorList errors={form.errors} />\n\t\t\t</Form>\n\t\t</div>;\n}\n_s(PhotoRoute, \"iHeSpgIHVoJLphdT2VOeEhrdia8=\", false, function () {\n  return [useLoaderData, useDoubleCheck, useActionData, useNavigation, useForm, useIsPending];\n});\n_c = PhotoRoute;\nvar _c;\n$RefreshReg$(_c, \"PhotoRoute\");\n\nwindow.$RefreshReg$ = prevRefreshReg;\nwindow.$RefreshSig$ = prevRefreshSig;"],
  "mappings": "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",
  "names": ["import_react"]
}
