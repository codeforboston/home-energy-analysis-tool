{
  "version": 3,
  "sources": ["empty-module:./auth.server.ts", "empty-module:./db.server.ts", "../../../app/utils/permissions.ts"],
  "sourcesContent": ["module.exports = {};", "module.exports = {};", "// REMIX HMR BEGIN\nimport * as __hmr__ from \"remix:hmr\";\nif (import.meta) {\nimport.meta.hot = __hmr__.createHotContext(\n//@ts-expect-error\n\"app/utils/permissions.ts\"\n);\nimport.meta.hot.lastModified = \"1706218436656.8838\";\n}\n// REMIX HMR END\n\nimport { json } from '@remix-run/node'\nimport { requireUserId } from './auth.server.ts'\nimport { prisma } from './db.server.ts'\nimport { type useUser } from './user.ts'\n\nexport async function requireUserWithPermission(\n\trequest: Request,\n\tpermission: PermissionString,\n) {\n\tconst userId = await requireUserId(request)\n\tconst permissionData = parsePermissionString(permission)\n\tconst user = await prisma.user.findFirst({\n\t\tselect: { id: true },\n\t\twhere: {\n\t\t\tid: userId,\n\t\t\troles: {\n\t\t\t\tsome: {\n\t\t\t\t\tpermissions: {\n\t\t\t\t\t\tsome: {\n\t\t\t\t\t\t\t...permissionData,\n\t\t\t\t\t\t\taccess: permissionData.access\n\t\t\t\t\t\t\t\t? { in: permissionData.access }\n\t\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t})\n\tif (!user) {\n\t\tthrow json(\n\t\t\t{\n\t\t\t\terror: 'Unauthorized',\n\t\t\t\trequiredPermission: permissionData,\n\t\t\t\tmessage: `Unauthorized: required permissions: ${permission}`,\n\t\t\t},\n\t\t\t{ status: 403 },\n\t\t)\n\t}\n\treturn user.id\n}\n\nexport async function requireUserWithRole(request: Request, name: string) {\n\tconst userId = await requireUserId(request)\n\tconst user = await prisma.user.findFirst({\n\t\tselect: { id: true },\n\t\twhere: { id: userId, roles: { some: { name } } },\n\t})\n\tif (!user) {\n\t\tthrow json(\n\t\t\t{\n\t\t\t\terror: 'Unauthorized',\n\t\t\t\trequiredRole: name,\n\t\t\t\tmessage: `Unauthorized: required role: ${name}`,\n\t\t\t},\n\t\t\t{ status: 403 },\n\t\t)\n\t}\n\treturn user.id\n}\n\ntype Action = 'create' | 'read' | 'update' | 'delete'\ntype Entity = 'user' | 'note'\ntype Access = 'own' | 'any' | 'own,any' | 'any,own'\ntype PermissionString = `${Action}:${Entity}` | `${Action}:${Entity}:${Access}`\nfunction parsePermissionString(permissionString: PermissionString) {\n\tconst [action, entity, access] = permissionString.split(':') as [\n\t\tAction,\n\t\tEntity,\n\t\tAccess | undefined,\n\t]\n\treturn {\n\t\taction,\n\t\tentity,\n\t\taccess: access ? (access.split(',') as Array<Access>) : undefined,\n\t}\n}\n\nexport function userHasPermission(\n\tuser: Pick<ReturnType<typeof useUser>, 'roles'> | null | undefined,\n\tpermission: PermissionString,\n) {\n\tif (!user) return false\n\tconst { action, entity, access } = parsePermissionString(permission)\n\treturn user.roles.some(role =>\n\t\trole.permissions.some(\n\t\t\tpermission =>\n\t\t\t\tpermission.entity === entity &&\n\t\t\t\tpermission.action === action &&\n\t\t\t\t(!access || access.includes(permission.access)),\n\t\t),\n\t)\n}\n\nexport function userHasRole(\n\tuser: Pick<ReturnType<typeof useUser>, 'roles'> | null,\n\trole: string,\n) {\n\tif (!user) return false\n\treturn user.roles.some(r => r.name === role)\n}\n"],
  "mappings": ";;;;;;;;;;;;AAAA;AAAA;AAAA,WAAO,UAAU,CAAC;AAAA;AAAA;;;ACAlB;AAAA;AAAA,WAAO,UAAU,CAAC;AAAA;AAAA;;;ACWlB,kBAAqB;AACrB,yBAA8B;AAC9B,uBAAuB;AAXvB,IAAI,aAAa;AACjB,cAAY,MAAc;AAAA;AAAA,IAE1B;AAAA,EACA;AACA,cAAY,IAAI,eAAe;AAC/B;AAoEA,SAAS,sBAAsB,kBAAoC;AAClE,QAAM,CAAC,QAAQ,QAAQ,MAAM,IAAI,iBAAiB,MAAM,GAAG;AAK3D,SAAO;AAAA,IACN;AAAA,IACA;AAAA,IACA,QAAQ,SAAU,OAAO,MAAM,GAAG,IAAsB;AAAA,EACzD;AACD;AAEO,SAAS,kBACf,MACA,YACC;AACD,MAAI,CAAC;AAAM,WAAO;AAClB,QAAM,EAAE,QAAQ,QAAQ,OAAO,IAAI,sBAAsB,UAAU;AACnE,SAAO,KAAK,MAAM;AAAA,IAAK,UACtB,KAAK,YAAY;AAAA,MAChB,CAAAA,gBACCA,YAAW,WAAW,UACtBA,YAAW,WAAW,WACrB,CAAC,UAAU,OAAO,SAASA,YAAW,MAAM;AAAA,IAC/C;AAAA,EACD;AACD;",
  "names": ["permission"]
}
