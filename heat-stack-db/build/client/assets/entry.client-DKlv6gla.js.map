{"version":3,"mappings":"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","names":["RemixErrorBoundary","React.Component","props","error","state","React.createElement","RemixRootDefaultErrorBoundary","heyDeveloper","isRouteErrorResponse","BoundaryShell","errorInstance","errorString","title","renderScripts","children","_routeModules$root","routeModules","useRemixContext","Scripts","deserializeErrors","errors","entries","serialized","key","val","UNSAFE_ErrorResponseImpl","ErrorConstructor","RemixRootDefaultHydrateFallback","groupRoutesByParentId","manifest","routes","route","parentId","getRouteComponents","routeModule","isSpaMode","Component","getRouteModuleComponent","HydrateFallback","ErrorBoundary","useRouteError","createClientRoutesWithHMRRevalidationOptOut","needsRevalidation","routeModulesCache","initialState","future","createClientRoutes","preventInvalidServerHandlerCall","type","msg","noActionDefinedError","routeId","article","routesByParentId","fetchServerHandlerAndMaybeUnwrap","request","unwrap","singleFetch","result","fetchServerHandler","unwrapServerResponse","fetchServerLoader","fetchServerAction","prefetchStylesAndCallHandler","handler","cachedModule","linkPrefetchPromise","prefetchStyleLinks","dataRoute","_initialState$loaderD","_initialState$errors","_routeModule$clientLo","wrapShouldRevalidateForHdr","initialData","initialError","isHydrationRequest","params","invariant","shouldHydrateRouteLoader","mod","loadRouteModuleWithBlockingLinks","lazyRoute","clientLoader","args","clientAction","routeShouldRevalidate","handledRevalidation","arg","loadRouteModule","fetchData","isRedirectResponse","getRedirect","isCatchResponse","isDeferredResponse","parseDeferredReadableStream","isDeferredData","isResponse","contentType","response","status","url","headers","revalidate","reloadDocument","redirect","stateDecodingPromise","router","routerInitialized","hmrRouterReadyResolve","hmrRouterReadyPromise","resolve","RemixBrowser","_props","initialPathname","hydratedPathname","errorMsg","React.Fragment","stream","decodeViaTurboStream","value","e","hydrationData","initialMatches","matchRoutes","match","manifestRoute","createRouter","createBrowserHistory","UNSAFE_mapRouteProperties","getSingleFetchDataStrategy","criticalCss","setCriticalCss","React.useState","location","setLocation","React.useLayoutEffect","newState","RemixContext","RouterProvider","m","require$$0","hydrateRoot","__vitePreload","init","startTransition","jsx"],"ignoreList":[0,1,2,3,4,5],"sources":["../../../node_modules/@remix-run/react/dist/esm/errorBoundaries.js","../../../node_modules/@remix-run/react/dist/esm/errors.js","../../../node_modules/@remix-run/react/dist/esm/fallback.js","../../../node_modules/@remix-run/react/dist/esm/routes.js","../../../node_modules/@remix-run/react/dist/esm/browser.js","../../../node_modules/react-dom/client.js","../../../app/entry.client.tsx"],"sourcesContent":["/**\n * @remix-run/react v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport * as React from 'react';\nimport { isRouteErrorResponse } from 'react-router-dom';\nimport { useRemixContext, Scripts } from './components.js';\n\nclass RemixErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      error: props.error || null,\n      location: props.location\n    };\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      error\n    };\n  }\n  static getDerivedStateFromProps(props, state) {\n    // When we get into an error state, the user will likely click \"back\" to the\n    // previous page that didn't have an error. Because this wraps the entire\n    // application (even the HTML!) that will have no effect--the error page\n    // continues to display. This gives us a mechanism to recover from the error\n    // when the location changes.\n    //\n    // Whether we're in an error state or not, we update the location in state\n    // so that when we are in an error state, it gets reset when a new location\n    // comes in and the user recovers from the error.\n    if (state.location !== props.location) {\n      return {\n        error: props.error || null,\n        location: props.location\n      };\n    }\n\n    // If we're not changing locations, preserve the location but still surface\n    // any new errors that may come through. We retain the existing error, we do\n    // this because the error provided from the app state may be cleared without\n    // the location changing.\n    return {\n      error: props.error || state.error,\n      location: state.location\n    };\n  }\n  render() {\n    if (this.state.error) {\n      return /*#__PURE__*/React.createElement(RemixRootDefaultErrorBoundary, {\n        error: this.state.error\n      });\n    } else {\n      return this.props.children;\n    }\n  }\n}\n\n/**\n * When app's don't provide a root level ErrorBoundary, we default to this.\n */\nfunction RemixRootDefaultErrorBoundary({\n  error\n}) {\n  console.error(error);\n  let heyDeveloper = /*#__PURE__*/React.createElement(\"script\", {\n    dangerouslySetInnerHTML: {\n      __html: `\n        console.log(\n          \"ðŸ’¿ Hey developer ðŸ‘‹. You can provide a way better UX than this when your app throws errors. Check out https://remix.run/guides/errors for more information.\"\n        );\n      `\n    }\n  });\n  if (isRouteErrorResponse(error)) {\n    return /*#__PURE__*/React.createElement(BoundaryShell, {\n      title: \"Unhandled Thrown Response!\"\n    }, /*#__PURE__*/React.createElement(\"h1\", {\n      style: {\n        fontSize: \"24px\"\n      }\n    }, error.status, \" \", error.statusText), heyDeveloper);\n  }\n  let errorInstance;\n  if (error instanceof Error) {\n    errorInstance = error;\n  } else {\n    let errorString = error == null ? \"Unknown Error\" : typeof error === \"object\" && \"toString\" in error ? error.toString() : JSON.stringify(error);\n    errorInstance = new Error(errorString);\n  }\n  return /*#__PURE__*/React.createElement(BoundaryShell, {\n    title: \"Application Error!\"\n  }, /*#__PURE__*/React.createElement(\"h1\", {\n    style: {\n      fontSize: \"24px\"\n    }\n  }, \"Application Error\"), /*#__PURE__*/React.createElement(\"pre\", {\n    style: {\n      padding: \"2rem\",\n      background: \"hsla(10, 50%, 50%, 0.1)\",\n      color: \"red\",\n      overflow: \"auto\"\n    }\n  }, errorInstance.stack), heyDeveloper);\n}\nfunction BoundaryShell({\n  title,\n  renderScripts,\n  children\n}) {\n  var _routeModules$root;\n  let {\n    routeModules\n  } = useRemixContext();\n  if ((_routeModules$root = routeModules.root) !== null && _routeModules$root !== void 0 && _routeModules$root.Layout) {\n    return children;\n  }\n  return /*#__PURE__*/React.createElement(\"html\", {\n    lang: \"en\"\n  }, /*#__PURE__*/React.createElement(\"head\", null, /*#__PURE__*/React.createElement(\"meta\", {\n    charSet: \"utf-8\"\n  }), /*#__PURE__*/React.createElement(\"meta\", {\n    name: \"viewport\",\n    content: \"width=device-width,initial-scale=1,viewport-fit=cover\"\n  }), /*#__PURE__*/React.createElement(\"title\", null, title)), /*#__PURE__*/React.createElement(\"body\", null, /*#__PURE__*/React.createElement(\"main\", {\n    style: {\n      fontFamily: \"system-ui, sans-serif\",\n      padding: \"2rem\"\n    }\n  }, children, renderScripts ? /*#__PURE__*/React.createElement(Scripts, null) : null)));\n}\n\nexport { BoundaryShell, RemixErrorBoundary, RemixRootDefaultErrorBoundary };\n","/**\n * @remix-run/react v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { UNSAFE_ErrorResponseImpl } from '@remix-run/router';\n\nfunction deserializeErrors(errors) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    // Hey you!  If you change this, please change the corresponding logic in\n    // serializeErrors in remix-server-runtime/errors.ts :)\n    if (val && val.__type === \"RouteErrorResponse\") {\n      serialized[key] = new UNSAFE_ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);\n    } else if (val && val.__type === \"Error\") {\n      // Attempt to reconstruct the right type of Error (i.e., ReferenceError)\n      if (val.__subType) {\n        let ErrorConstructor = window[val.__subType];\n        if (typeof ErrorConstructor === \"function\") {\n          try {\n            // @ts-expect-error\n            let error = new ErrorConstructor(val.message);\n            error.stack = val.stack;\n            serialized[key] = error;\n          } catch (e) {\n            // no-op - fall through and create a normal Error\n          }\n        }\n      }\n      if (serialized[key] == null) {\n        let error = new Error(val.message);\n        error.stack = val.stack;\n        serialized[key] = error;\n      }\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\n\nexport { deserializeErrors };\n","/**\n * @remix-run/react v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport * as React from 'react';\nimport { BoundaryShell } from './errorBoundaries.js';\n\n// If the user sets `clientLoader.hydrate=true` somewhere but does not\n// provide a `HydrateFallback` at any level of the tree, then we need to at\n// least include `<Scripts>` in the SSR so we can hydrate the app and call the\n// `clientLoader` functions\nfunction RemixRootDefaultHydrateFallback() {\n  return /*#__PURE__*/React.createElement(BoundaryShell, {\n    title: \"Loading...\",\n    renderScripts: true\n  }, /*#__PURE__*/React.createElement(\"script\", {\n    dangerouslySetInnerHTML: {\n      __html: `\n              console.log(\n                \"ðŸ’¿ Hey developer ðŸ‘‹. You can provide a way better UX than this \" +\n                \"when your app is running \\`clientLoader\\` functions on hydration. \" +\n                \"Check out https://remix.run/route/hydrate-fallback for more information.\"\n              );\n            `\n    }\n  }));\n}\n\nexport { RemixRootDefaultHydrateFallback };\n","/**\n * @remix-run/react v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport * as React from 'react';\nimport { UNSAFE_ErrorResponseImpl } from '@remix-run/router';\nimport { useRouteError, redirect } from 'react-router-dom';\nimport { loadRouteModule } from './routeModules.js';\nimport { fetchData, isRedirectResponse, isCatchResponse, isDeferredResponse, parseDeferredReadableStream, isDeferredData, isResponse } from './data.js';\nimport { prefetchStyleLinks } from './links.js';\nimport { RemixRootDefaultErrorBoundary } from './errorBoundaries.js';\nimport { RemixRootDefaultHydrateFallback } from './fallback.js';\nimport invariant from './invariant.js';\n\n// NOTE: make sure to change the Route in server-runtime if you change this\n\n// NOTE: make sure to change the EntryRoute in server-runtime if you change this\n\n// Create a map of routes by parentId to use recursively instead of\n// repeatedly filtering the manifest.\nfunction groupRoutesByParentId(manifest) {\n  let routes = {};\n  Object.values(manifest).forEach(route => {\n    let parentId = route.parentId || \"\";\n    if (!routes[parentId]) {\n      routes[parentId] = [];\n    }\n    routes[parentId].push(route);\n  });\n  return routes;\n}\nfunction getRouteComponents(route, routeModule, isSpaMode) {\n  let Component = getRouteModuleComponent(routeModule);\n  // HydrateFallback can only exist on the root route in SPA Mode\n  let HydrateFallback = routeModule.HydrateFallback && (!isSpaMode || route.id === \"root\") ? routeModule.HydrateFallback : route.id === \"root\" ? RemixRootDefaultHydrateFallback : undefined;\n  let ErrorBoundary = routeModule.ErrorBoundary ? routeModule.ErrorBoundary : route.id === \"root\" ? () => /*#__PURE__*/React.createElement(RemixRootDefaultErrorBoundary, {\n    error: useRouteError()\n  }) : undefined;\n  if (route.id === \"root\" && routeModule.Layout) {\n    return {\n      ...(Component ? {\n        element: /*#__PURE__*/React.createElement(routeModule.Layout, null, /*#__PURE__*/React.createElement(Component, null))\n      } : {\n        Component\n      }),\n      ...(ErrorBoundary ? {\n        errorElement: /*#__PURE__*/React.createElement(routeModule.Layout, null, /*#__PURE__*/React.createElement(ErrorBoundary, null))\n      } : {\n        ErrorBoundary\n      }),\n      ...(HydrateFallback ? {\n        hydrateFallbackElement: /*#__PURE__*/React.createElement(routeModule.Layout, null, /*#__PURE__*/React.createElement(HydrateFallback, null))\n      } : {\n        HydrateFallback\n      })\n    };\n  }\n  return {\n    Component,\n    ErrorBoundary,\n    HydrateFallback\n  };\n}\nfunction createServerRoutes(manifest, routeModules, future, isSpaMode, parentId = \"\", routesByParentId = groupRoutesByParentId(manifest), spaModeLazyPromise = Promise.resolve({\n  Component: () => null\n})) {\n  return (routesByParentId[parentId] || []).map(route => {\n    let routeModule = routeModules[route.id];\n    invariant(routeModule, \"No `routeModule` available to create server routes\");\n    let dataRoute = {\n      ...getRouteComponents(route, routeModule, isSpaMode),\n      caseSensitive: route.caseSensitive,\n      id: route.id,\n      index: route.index,\n      path: route.path,\n      handle: routeModule.handle,\n      // For SPA Mode, all routes are lazy except root.  However we tell the\n      // router root is also lazy here too since we don't need a full\n      // implementation - we just need a `lazy` prop to tell the RR rendering\n      // where to stop which is always at the root route in SPA mode\n      lazy: isSpaMode ? () => spaModeLazyPromise : undefined,\n      // For partial hydration rendering, we need to indicate when the route\n      // has a loader/clientLoader, but it won't ever be called during the static\n      // render, so just give it a no-op function so we can render down to the\n      // proper fallback\n      loader: route.hasLoader || route.hasClientLoader ? () => null : undefined\n      // We don't need action/shouldRevalidate on these routes since they're\n      // for a static render\n    };\n    let children = createServerRoutes(manifest, routeModules, future, isSpaMode, route.id, routesByParentId, spaModeLazyPromise);\n    if (children.length > 0) dataRoute.children = children;\n    return dataRoute;\n  });\n}\nfunction createClientRoutesWithHMRRevalidationOptOut(needsRevalidation, manifest, routeModulesCache, initialState, future, isSpaMode) {\n  return createClientRoutes(manifest, routeModulesCache, initialState, future, isSpaMode, \"\", groupRoutesByParentId(manifest), needsRevalidation);\n}\nfunction preventInvalidServerHandlerCall(type, route, isSpaMode) {\n  if (isSpaMode) {\n    let fn = type === \"action\" ? \"serverAction()\" : \"serverLoader()\";\n    let msg = `You cannot call ${fn} in SPA Mode (routeId: \"${route.id}\")`;\n    console.error(msg);\n    throw new UNSAFE_ErrorResponseImpl(400, \"Bad Request\", new Error(msg), true);\n  }\n  let fn = type === \"action\" ? \"serverAction()\" : \"serverLoader()\";\n  let msg = `You are trying to call ${fn} on a route that does not have a server ` + `${type} (routeId: \"${route.id}\")`;\n  if (type === \"loader\" && !route.hasLoader || type === \"action\" && !route.hasAction) {\n    console.error(msg);\n    throw new UNSAFE_ErrorResponseImpl(400, \"Bad Request\", new Error(msg), true);\n  }\n}\nfunction noActionDefinedError(type, routeId) {\n  let article = type === \"clientAction\" ? \"a\" : \"an\";\n  let msg = `Route \"${routeId}\" does not have ${article} ${type}, but you are trying to ` + `submit to it. To fix this, please add ${article} \\`${type}\\` function to the route`;\n  console.error(msg);\n  throw new UNSAFE_ErrorResponseImpl(405, \"Method Not Allowed\", new Error(msg), true);\n}\nfunction createClientRoutes(manifest, routeModulesCache, initialState, future, isSpaMode, parentId = \"\", routesByParentId = groupRoutesByParentId(manifest), needsRevalidation) {\n  return (routesByParentId[parentId] || []).map(route => {\n    let routeModule = routeModulesCache[route.id];\n\n    // Fetch data from the server either via single fetch or the standard `?_data`\n    // request.  Unwrap it when called via `serverLoader`/`serverAction` in a\n    // client handler, otherwise return the raw response for the router to unwrap\n    async function fetchServerHandlerAndMaybeUnwrap(request, unwrap, singleFetch) {\n      if (typeof singleFetch === \"function\") {\n        let result = await singleFetch();\n        return result;\n      }\n      let result = await fetchServerHandler(request, route);\n      return unwrap ? unwrapServerResponse(result) : result;\n    }\n    function fetchServerLoader(request, unwrap, singleFetch) {\n      if (!route.hasLoader) return Promise.resolve(null);\n      return fetchServerHandlerAndMaybeUnwrap(request, unwrap, singleFetch);\n    }\n    function fetchServerAction(request, unwrap, singleFetch) {\n      if (!route.hasAction) {\n        throw noActionDefinedError(\"action\", route.id);\n      }\n      return fetchServerHandlerAndMaybeUnwrap(request, unwrap, singleFetch);\n    }\n    async function prefetchStylesAndCallHandler(handler) {\n      // Only prefetch links if we exist in the routeModulesCache (critical modules\n      // and navigating back to pages previously loaded via route.lazy).  Initial\n      // execution of route.lazy (when the module is not in the cache) will handle\n      // prefetching style links via loadRouteModuleWithBlockingLinks.\n      let cachedModule = routeModulesCache[route.id];\n      let linkPrefetchPromise = cachedModule ? prefetchStyleLinks(route, cachedModule) : Promise.resolve();\n      try {\n        return handler();\n      } finally {\n        await linkPrefetchPromise;\n      }\n    }\n    let dataRoute = {\n      id: route.id,\n      index: route.index,\n      path: route.path\n    };\n    if (routeModule) {\n      var _initialState$loaderD, _initialState$errors, _routeModule$clientLo;\n      // Use critical path modules directly\n      Object.assign(dataRoute, {\n        ...dataRoute,\n        ...getRouteComponents(route, routeModule, isSpaMode),\n        handle: routeModule.handle,\n        shouldRevalidate: needsRevalidation ? wrapShouldRevalidateForHdr(route.id, routeModule.shouldRevalidate, needsRevalidation) : routeModule.shouldRevalidate\n      });\n      let initialData = initialState === null || initialState === void 0 ? void 0 : (_initialState$loaderD = initialState.loaderData) === null || _initialState$loaderD === void 0 ? void 0 : _initialState$loaderD[route.id];\n      let initialError = initialState === null || initialState === void 0 ? void 0 : (_initialState$errors = initialState.errors) === null || _initialState$errors === void 0 ? void 0 : _initialState$errors[route.id];\n      let isHydrationRequest = needsRevalidation == null && (((_routeModule$clientLo = routeModule.clientLoader) === null || _routeModule$clientLo === void 0 ? void 0 : _routeModule$clientLo.hydrate) === true || !route.hasLoader);\n      dataRoute.loader = async ({\n        request,\n        params\n      }, singleFetch) => {\n        try {\n          let result = await prefetchStylesAndCallHandler(async () => {\n            invariant(routeModule, \"No `routeModule` available for critical-route loader\");\n            if (!routeModule.clientLoader) {\n              if (isSpaMode) return null;\n              // Call the server when no client loader exists\n              return fetchServerLoader(request, false, singleFetch);\n            }\n            return routeModule.clientLoader({\n              request,\n              params,\n              async serverLoader() {\n                preventInvalidServerHandlerCall(\"loader\", route, isSpaMode);\n\n                // On the first call, resolve with the server result\n                if (isHydrationRequest) {\n                  if (initialError !== undefined) {\n                    throw initialError;\n                  }\n                  return initialData;\n                }\n\n                // Call the server loader for client-side navigations\n                return fetchServerLoader(request, true, singleFetch);\n              }\n            });\n          });\n          return result;\n        } finally {\n          // Whether or not the user calls `serverLoader`, we only let this\n          // stick around as true for one loader call\n          isHydrationRequest = false;\n        }\n      };\n\n      // Let React Router know whether to run this on hydration\n      dataRoute.loader.hydrate = shouldHydrateRouteLoader(route, routeModule, isSpaMode);\n      dataRoute.action = ({\n        request,\n        params\n      }, singleFetch) => {\n        return prefetchStylesAndCallHandler(async () => {\n          invariant(routeModule, \"No `routeModule` available for critical-route action\");\n          if (!routeModule.clientAction) {\n            if (isSpaMode) {\n              throw noActionDefinedError(\"clientAction\", route.id);\n            }\n            return fetchServerAction(request, false, singleFetch);\n          }\n          return routeModule.clientAction({\n            request,\n            params,\n            async serverAction() {\n              preventInvalidServerHandlerCall(\"action\", route, isSpaMode);\n              return fetchServerAction(request, true, singleFetch);\n            }\n          });\n        });\n      };\n    } else {\n      // If the lazy route does not have a client loader/action we want to call\n      // the server loader/action in parallel with the module load so we add\n      // loader/action as static props on the route\n      if (!route.hasClientLoader) {\n        dataRoute.loader = ({\n          request\n        }, singleFetch) => prefetchStylesAndCallHandler(() => {\n          if (isSpaMode) return Promise.resolve(null);\n          return fetchServerLoader(request, false, singleFetch);\n        });\n      }\n      if (!route.hasClientAction) {\n        dataRoute.action = ({\n          request\n        }, singleFetch) => prefetchStylesAndCallHandler(() => {\n          if (isSpaMode) {\n            throw noActionDefinedError(\"clientAction\", route.id);\n          }\n          return fetchServerAction(request, false, singleFetch);\n        });\n      }\n\n      // Load all other modules via route.lazy()\n      dataRoute.lazy = async () => {\n        let mod = await loadRouteModuleWithBlockingLinks(route, routeModulesCache);\n        let lazyRoute = {\n          ...mod\n        };\n        if (mod.clientLoader) {\n          let clientLoader = mod.clientLoader;\n          lazyRoute.loader = (args, singleFetch) => clientLoader({\n            ...args,\n            async serverLoader() {\n              preventInvalidServerHandlerCall(\"loader\", route, isSpaMode);\n              return fetchServerLoader(args.request, true, singleFetch);\n            }\n          });\n        }\n        if (mod.clientAction) {\n          let clientAction = mod.clientAction;\n          lazyRoute.action = (args, singleFetch) => clientAction({\n            ...args,\n            async serverAction() {\n              preventInvalidServerHandlerCall(\"action\", route, isSpaMode);\n              return fetchServerAction(args.request, true, singleFetch);\n            }\n          });\n        }\n        if (needsRevalidation) {\n          lazyRoute.shouldRevalidate = wrapShouldRevalidateForHdr(route.id, mod.shouldRevalidate, needsRevalidation);\n        }\n        return {\n          ...(lazyRoute.loader ? {\n            loader: lazyRoute.loader\n          } : {}),\n          ...(lazyRoute.action ? {\n            action: lazyRoute.action\n          } : {}),\n          hasErrorBoundary: lazyRoute.hasErrorBoundary,\n          shouldRevalidate: lazyRoute.shouldRevalidate,\n          handle: lazyRoute.handle,\n          // No need to wrap these in layout since the root route is never\n          // loaded via route.lazy()\n          Component: lazyRoute.Component,\n          ErrorBoundary: lazyRoute.ErrorBoundary\n        };\n      };\n    }\n    let children = createClientRoutes(manifest, routeModulesCache, initialState, future, isSpaMode, route.id, routesByParentId, needsRevalidation);\n    if (children.length > 0) dataRoute.children = children;\n    return dataRoute;\n  });\n}\n\n// When an HMR / HDR update happens we opt out of all user-defined\n// revalidation logic and force a revalidation on the first call\nfunction wrapShouldRevalidateForHdr(routeId, routeShouldRevalidate, needsRevalidation) {\n  let handledRevalidation = false;\n  return arg => {\n    if (!handledRevalidation) {\n      handledRevalidation = true;\n      return needsRevalidation.has(routeId);\n    }\n    return routeShouldRevalidate ? routeShouldRevalidate(arg) : arg.defaultShouldRevalidate;\n  };\n}\nasync function loadRouteModuleWithBlockingLinks(route, routeModules) {\n  let routeModule = await loadRouteModule(route, routeModules);\n  await prefetchStyleLinks(route, routeModule);\n\n  // Include all `browserSafeRouteExports` fields, except `HydrateFallback`\n  // since those aren't used on lazily loaded routes\n  return {\n    Component: getRouteModuleComponent(routeModule),\n    ErrorBoundary: routeModule.ErrorBoundary,\n    clientAction: routeModule.clientAction,\n    clientLoader: routeModule.clientLoader,\n    handle: routeModule.handle,\n    links: routeModule.links,\n    meta: routeModule.meta,\n    shouldRevalidate: routeModule.shouldRevalidate\n  };\n}\nasync function fetchServerHandler(request, route) {\n  let result = await fetchData(request, route.id);\n  if (result instanceof Error) {\n    throw result;\n  }\n  if (isRedirectResponse(result)) {\n    throw getRedirect(result);\n  }\n  if (isCatchResponse(result)) {\n    throw result;\n  }\n  if (isDeferredResponse(result) && result.body) {\n    return await parseDeferredReadableStream(result.body);\n  }\n  return result;\n}\nfunction unwrapServerResponse(result) {\n  if (isDeferredData(result)) {\n    return result.data;\n  }\n  if (isResponse(result)) {\n    let contentType = result.headers.get(\"Content-Type\");\n    // Check between word boundaries instead of startsWith() due to the last\n    // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\n    if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n      return result.json();\n    } else {\n      return result.text();\n    }\n  }\n  return result;\n}\nfunction getRedirect(response) {\n  let status = parseInt(response.headers.get(\"X-Remix-Status\"), 10) || 302;\n  let url = response.headers.get(\"X-Remix-Redirect\");\n  let headers = {};\n  let revalidate = response.headers.get(\"X-Remix-Revalidate\");\n  if (revalidate) {\n    headers[\"X-Remix-Revalidate\"] = revalidate;\n  }\n  let reloadDocument = response.headers.get(\"X-Remix-Reload-Document\");\n  if (reloadDocument) {\n    headers[\"X-Remix-Reload-Document\"] = reloadDocument;\n  }\n  return redirect(url, {\n    status,\n    headers\n  });\n}\n\n// Our compiler generates the default export as `{}` when no default is provided,\n// which can lead us to trying to use that as a Component in RR and calling\n// createElement on it.  Patching here as a quick fix and hoping it's no longer\n// an issue in Vite.\nfunction getRouteModuleComponent(routeModule) {\n  if (routeModule.default == null) return undefined;\n  let isEmptyObject = typeof routeModule.default === \"object\" && Object.keys(routeModule.default).length === 0;\n  if (!isEmptyObject) {\n    return routeModule.default;\n  }\n}\nfunction shouldHydrateRouteLoader(route, routeModule, isSpaMode) {\n  return isSpaMode && route.id !== \"root\" || routeModule.clientLoader != null && (routeModule.clientLoader.hydrate === true || route.hasLoader !== true);\n}\n\nexport { createClientRoutes, createClientRoutesWithHMRRevalidationOptOut, createServerRoutes, shouldHydrateRouteLoader };\n","/**\n * @remix-run/react v2.9.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { createRouter, createBrowserHistory } from '@remix-run/router';\nimport * as React from 'react';\nimport { UNSAFE_mapRouteProperties } from 'react-router';\nimport { matchRoutes, RouterProvider } from 'react-router-dom';\nimport { RemixContext } from './components.js';\nimport { RemixErrorBoundary } from './errorBoundaries.js';\nimport { deserializeErrors } from './errors.js';\nimport { createClientRoutesWithHMRRevalidationOptOut, createClientRoutes, shouldHydrateRouteLoader } from './routes.js';\nimport { decodeViaTurboStream, getSingleFetchDataStrategy } from './single-fetch.js';\nimport invariant from './invariant.js';\n\n/* eslint-disable prefer-let/prefer-let */\n\n/* eslint-enable prefer-let/prefer-let */\n\nlet stateDecodingPromise;\nlet router;\nlet routerInitialized = false;\nlet hmrAbortController;\nlet hmrRouterReadyResolve;\n// There's a race condition with HMR where the remix:manifest is signaled before\n// the router is assigned in the RemixBrowser component. This promise gates the\n// HMR handler until the router is ready\nlet hmrRouterReadyPromise = new Promise(resolve => {\n  // body of a promise is executed immediately, so this can be resolved outside\n  // of the promise body\n  hmrRouterReadyResolve = resolve;\n}).catch(() => {\n  // This is a noop catch handler to avoid unhandled promise rejection warnings\n  // in the console. The promise is never rejected.\n  return undefined;\n});\n\n// @ts-expect-error\nif (import.meta && import.meta.hot) {\n  // @ts-expect-error\n  import.meta.hot.accept(\"remix:manifest\", async ({\n    assetsManifest,\n    needsRevalidation\n  }) => {\n    let router = await hmrRouterReadyPromise;\n    // This should never happen, but just in case...\n    if (!router) {\n      console.error(\"Failed to accept HMR update because the router was not ready.\");\n      return;\n    }\n    let routeIds = [...new Set(router.state.matches.map(m => m.route.id).concat(Object.keys(window.__remixRouteModules)))];\n    if (hmrAbortController) {\n      hmrAbortController.abort();\n    }\n    hmrAbortController = new AbortController();\n    let signal = hmrAbortController.signal;\n\n    // Load new route modules that we've seen.\n    let newRouteModules = Object.assign({}, window.__remixRouteModules, Object.fromEntries((await Promise.all(routeIds.map(async id => {\n      var _assetsManifest$hmr, _window$__remixRouteM, _window$__remixRouteM2, _window$__remixRouteM3;\n      if (!assetsManifest.routes[id]) {\n        return null;\n      }\n      let imported = await import(assetsManifest.routes[id].module + `?t=${(_assetsManifest$hmr = assetsManifest.hmr) === null || _assetsManifest$hmr === void 0 ? void 0 : _assetsManifest$hmr.timestamp}`);\n      return [id, {\n        ...imported,\n        // react-refresh takes care of updating these in-place,\n        // if we don't preserve existing values we'll loose state.\n        default: imported.default ? ((_window$__remixRouteM = window.__remixRouteModules[id]) === null || _window$__remixRouteM === void 0 ? void 0 : _window$__remixRouteM.default) ?? imported.default : imported.default,\n        ErrorBoundary: imported.ErrorBoundary ? ((_window$__remixRouteM2 = window.__remixRouteModules[id]) === null || _window$__remixRouteM2 === void 0 ? void 0 : _window$__remixRouteM2.ErrorBoundary) ?? imported.ErrorBoundary : imported.ErrorBoundary,\n        HydrateFallback: imported.HydrateFallback ? ((_window$__remixRouteM3 = window.__remixRouteModules[id]) === null || _window$__remixRouteM3 === void 0 ? void 0 : _window$__remixRouteM3.HydrateFallback) ?? imported.HydrateFallback : imported.HydrateFallback\n      }];\n    }))).filter(Boolean)));\n    Object.assign(window.__remixRouteModules, newRouteModules);\n    // Create new routes\n    let routes = createClientRoutesWithHMRRevalidationOptOut(needsRevalidation, assetsManifest.routes, window.__remixRouteModules, window.__remixContext.state, window.__remixContext.future, window.__remixContext.isSpaMode);\n\n    // This is temporary API and will be more granular before release\n    router._internalSetRoutes(routes);\n\n    // Wait for router to be idle before updating the manifest and route modules\n    // and triggering a react-refresh\n    let unsub = router.subscribe(state => {\n      if (state.revalidation === \"idle\") {\n        unsub();\n        // Abort if a new update comes in while we're waiting for the\n        // router to be idle.\n        if (signal.aborted) return;\n        // Ensure RouterProvider setState has flushed before re-rendering\n        setTimeout(() => {\n          Object.assign(window.__remixManifest, assetsManifest);\n          window.$RefreshRuntime$.performReactRefresh();\n        }, 1);\n      }\n    });\n    window.__remixRevalidation = (window.__remixRevalidation || 0) + 1;\n    router.revalidate();\n  });\n}\n\n/**\n * The entry point for a Remix app when it is rendered in the browser (in\n * `app/entry.client.js`). This component is used by React to hydrate the HTML\n * that was received from the server.\n */\nfunction RemixBrowser(_props) {\n  if (!router) {\n    // Hard reload if the path we tried to load is not the current path.\n    // This is usually the result of 2 rapid back/forward clicks from an\n    // external site into a Remix app, where we initially start the load for\n    // one URL and while the JS chunks are loading a second forward click moves\n    // us to a new URL.  Avoid comparing search params because of CDNs which\n    // can be configured to ignore certain params and only pathname is relevant\n    // towards determining the route matches.\n    let initialPathname = window.__remixContext.url;\n    let hydratedPathname = window.location.pathname;\n    if (initialPathname !== hydratedPathname && !window.__remixContext.isSpaMode) {\n      let errorMsg = `Initial URL (${initialPathname}) does not match URL at time of hydration ` + `(${hydratedPathname}), reloading page...`;\n      console.error(errorMsg);\n      window.location.reload();\n      // Get out of here so the reload can happen - don't create the router\n      // since it'll then kick off unnecessary route.lazy() loads\n      return /*#__PURE__*/React.createElement(React.Fragment, null);\n    }\n\n    // When single fetch is enabled, we need to suspend until the initial state\n    // snapshot is decoded into window.__remixContext.state\n    if (window.__remixContext.future.unstable_singleFetch) {\n      // Note: `stateDecodingPromise` is not coupled to `router` - we'll reach this\n      // code potentially many times waiting for our state to arrive, but we'll\n      // then only get past here and create the `router` one time\n      if (!stateDecodingPromise) {\n        let stream = window.__remixContext.stream;\n        invariant(stream, \"No stream found for single fetch decoding\");\n        window.__remixContext.stream = undefined;\n        stateDecodingPromise = decodeViaTurboStream(stream, window).then(value => {\n          window.__remixContext.state = value.value;\n          stateDecodingPromise.value = true;\n        }).catch(e => {\n          stateDecodingPromise.error = e;\n        });\n      }\n      if (stateDecodingPromise.error) {\n        throw stateDecodingPromise.error;\n      }\n      if (!stateDecodingPromise.value) {\n        throw stateDecodingPromise;\n      }\n    }\n    let routes = createClientRoutes(window.__remixManifest.routes, window.__remixRouteModules, window.__remixContext.state, window.__remixContext.future, window.__remixContext.isSpaMode);\n    let hydrationData = undefined;\n    if (!window.__remixContext.isSpaMode) {\n      // Create a shallow clone of `loaderData` we can mutate for partial hydration.\n      // When a route exports a `clientLoader` and a `HydrateFallback`, the SSR will\n      // render the fallback so we need the client to do the same for hydration.\n      // The server loader data has already been exposed to these route `clientLoader`'s\n      // in `createClientRoutes` above, so we need to clear out the version we pass to\n      // `createBrowserRouter` so it initializes and runs the client loaders.\n      hydrationData = {\n        ...window.__remixContext.state,\n        loaderData: {\n          ...window.__remixContext.state.loaderData\n        }\n      };\n      let initialMatches = matchRoutes(routes, window.location);\n      if (initialMatches) {\n        for (let match of initialMatches) {\n          let routeId = match.route.id;\n          let route = window.__remixRouteModules[routeId];\n          let manifestRoute = window.__remixManifest.routes[routeId];\n          // Clear out the loaderData to avoid rendering the route component when the\n          // route opted into clientLoader hydration and either:\n          // * gave us a HydrateFallback\n          // * or doesn't have a server loader and we have no data to render\n          if (route && shouldHydrateRouteLoader(manifestRoute, route, window.__remixContext.isSpaMode) && (route.HydrateFallback || !manifestRoute.hasLoader)) {\n            hydrationData.loaderData[routeId] = undefined;\n          } else if (manifestRoute && !manifestRoute.hasLoader) {\n            // Since every Remix route gets a `loader` on the client side to load\n            // the route JS module, we need to add a `null` value to `loaderData`\n            // for any routes that don't have server loaders so our partial\n            // hydration logic doesn't kick off the route module loaders during\n            // hydration\n            hydrationData.loaderData[routeId] = null;\n          }\n        }\n      }\n      if (hydrationData && hydrationData.errors) {\n        hydrationData.errors = deserializeErrors(hydrationData.errors);\n      }\n    }\n\n    // We don't use createBrowserRouter here because we need fine-grained control\n    // over initialization to support synchronous `clientLoader` flows.\n    router = createRouter({\n      routes,\n      history: createBrowserHistory(),\n      basename: window.__remixContext.basename,\n      future: {\n        v7_normalizeFormMethod: true,\n        v7_fetcherPersist: window.__remixContext.future.v3_fetcherPersist,\n        v7_partialHydration: true,\n        v7_prependBasename: true,\n        v7_relativeSplatPath: window.__remixContext.future.v3_relativeSplatPath,\n        // Single fetch enables this underlying behavior\n        unstable_skipActionErrorRevalidation: window.__remixContext.future.unstable_singleFetch === true\n      },\n      hydrationData,\n      mapRouteProperties: UNSAFE_mapRouteProperties,\n      unstable_dataStrategy: window.__remixContext.future.unstable_singleFetch ? getSingleFetchDataStrategy(window.__remixManifest, window.__remixRouteModules) : undefined\n    });\n\n    // We can call initialize() immediately if the router doesn't have any\n    // loaders to run on hydration\n    if (router.state.initialized) {\n      routerInitialized = true;\n      router.initialize();\n    }\n\n    // @ts-ignore\n    router.createRoutesForHMR = createClientRoutesWithHMRRevalidationOptOut;\n    window.__remixRouter = router;\n\n    // Notify that the router is ready for HMR\n    if (hmrRouterReadyResolve) {\n      hmrRouterReadyResolve(router);\n    }\n  }\n\n  // Critical CSS can become stale after code changes, e.g. styles might be\n  // removed from a component, but the styles will still be present in the\n  // server HTML. This allows our HMR logic to clear the critical CSS state.\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  let [criticalCss, setCriticalCss] = React.useState(process.env.NODE_ENV === \"development\" ? window.__remixContext.criticalCss : undefined);\n  if (process.env.NODE_ENV === \"development\") {\n    window.__remixClearCriticalCss = () => setCriticalCss(undefined);\n  }\n\n  // This is due to the short circuit return above when the pathname doesn't\n  // match and we force a hard reload.  This is an exceptional scenario in which\n  // we can't hydrate anyway.\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  let [location, setLocation] = React.useState(router.state.location);\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  React.useLayoutEffect(() => {\n    // If we had to run clientLoaders on hydration, we delay initialization until\n    // after we've hydrated to avoid hydration issues from synchronous client loaders\n    if (!routerInitialized) {\n      routerInitialized = true;\n      router.initialize();\n    }\n  }, []);\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  React.useLayoutEffect(() => {\n    return router.subscribe(newState => {\n      if (newState.location !== location) {\n        setLocation(newState.location);\n      }\n    });\n  }, [location]);\n\n  // We need to include a wrapper RemixErrorBoundary here in case the root error\n  // boundary also throws and we need to bubble up outside of the router entirely.\n  // Then we need a stateful location here so the user can back-button navigate\n  // out of there\n  return (\n    /*#__PURE__*/\n    // This fragment is important to ensure we match the <RemixServer> JSX\n    // structure so that useId values hydrate correctly\n    React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(RemixContext.Provider, {\n      value: {\n        manifest: window.__remixManifest,\n        routeModules: window.__remixRouteModules,\n        future: window.__remixContext.future,\n        criticalCss,\n        isSpaMode: window.__remixContext.isSpaMode\n      }\n    }, /*#__PURE__*/React.createElement(RemixErrorBoundary, {\n      location: location\n    }, /*#__PURE__*/React.createElement(RouterProvider, {\n      router: router,\n      fallbackElement: null,\n      future: {\n        v7_startTransition: true\n      }\n    }))), window.__remixContext.future.unstable_singleFetch ? /*#__PURE__*/React.createElement(React.Fragment, null) : null)\n  );\n}\n\nexport { RemixBrowser };\n","'use strict';\n\nvar m = require('react-dom');\nif (process.env.NODE_ENV === 'production') {\n  exports.createRoot = m.createRoot;\n  exports.hydrateRoot = m.hydrateRoot;\n} else {\n  var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n  exports.createRoot = function(c, o) {\n    i.usingClientEntryPoint = true;\n    try {\n      return m.createRoot(c, o);\n    } finally {\n      i.usingClientEntryPoint = false;\n    }\n  };\n  exports.hydrateRoot = function(c, h, o) {\n    i.usingClientEntryPoint = true;\n    try {\n      return m.hydrateRoot(c, h, o);\n    } finally {\n      i.usingClientEntryPoint = false;\n    }\n  };\n}\n","import { RemixBrowser } from '@remix-run/react'\nimport { startTransition } from 'react'\nimport { hydrateRoot } from 'react-dom/client'\n\nif (ENV.MODE === 'production' && ENV.SENTRY_DSN) {\n\timport('./utils/monitoring.client.tsx').then(({ init }) => init())\n}\n\nstartTransition(() => {\n\thydrateRoot(document, <RemixBrowser />)\n})\n"],"file":"assets/entry.client-DKlv6gla.js"}